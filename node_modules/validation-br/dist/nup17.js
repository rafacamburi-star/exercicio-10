"use strict";
/**
 * isFederalProtocol()
 * Calcula se é um número válido de protocolo do Governo Federal Brasileiro
 *
 * @doc
 * O Número Unificado de Protocolo de processos do Governo Federal, também conhecido
 * como NUP17, deve ter 17 caracteres, incluindo o dígito verificador de 2 caracteres.
 *
 * 1) Partes do número
 *
 * - Os caracteres 1 a 5 são um código do órgão que gerou o protocolo.
 *
 * - Os caracteres 6 a 11 são o número sequencial do protocolo, sendo que
 * cada órgão emissor tem sua própria sequência e esta é reiniciada a cada ano.
 *
 * - Os caracteres 12 a 15 são referentes ao ano de protocolo
 *
 * - Os caracteres 16 a 17 são referentes ao Dígito Verificador
 *
 * 1.2) Exemplo
 * ---------------------------------------------------------------
 * |  Código do órgão |   Número Sequencial   |    Ano     | D  V
 *  2   3   0   3   7 . 0   0   1   4   6   2 / 2  0  2  1 - 6  5
 *
 * 2) Cálculo do primeiro DV.
 *
 *  - Soma-se o produto das algarismos 1 a 15 pelos números
 *    16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2
 *
 *    2   3   0   3   7   0   0   1   4   6   2   2   0   2   1
 *    x   x   x   x   x   x   x   x   x   x   x   x   x   x   x
 *   16  15  14  13  12  11  10   9   8   7   6   5   4   3   2
 * = 32 +45  +0 +39 +84  +0  +0  +9 +32 +42 +12 +10  +0  +6  +2 = 313
 *
 *  - O somatório encontrado é dividido por 11. O resto da divisão é subtraído de 11.
 *    313 / 11 tem resto 5. 11 - 5 = 6. DV1 é 6.
 *    Obs.: Caso o cálculo de DV1 retorne 10, o resultado será 0. Caso retorne 11, o DV
 *    será 1. Ou seja, se for maior ou igual a 10, desconsidere a casa das dezenas
 *
 * 3) Cálculo do segundo DV.
 *
 * - Acrescenta o valor do DV1 ao número e faz o somatório dos produtos pelos números
 *   17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2
 *
 *    2   3   0   3   7   0   0   1   4   6   2   2   0   2   1   6
 *    x   x   x   x   x   x   x   x   x   x   x   x   x   x   x   x
 *   17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2
 * = 34 +48  +0 +42 +91  +0  +0 +10 +36 +48 +14 +12  +0  +8  +3 +12 = 358
 *
 *  - O somatório encontrado é dividido por 11. O resto da divisão é subtraído de 11.
 *    358 / 11 tem resto 6. 11 - 6 = 1. DV1 é 5.
 *    Obs.: Caso o cálculo de DV1 retorne 10, o resultado será 0. Caso retorne 11, o DV
 *    será 1. Ou seja, se for maior ou igual a 10, desconsidere a casa das dezenas.
 *
 * = DV = 65
 *
 * Fonte: https://www.gov.br/compras/pt-br/acesso-a-informacao/legislacao/portarias/portaria-interministerial-no-11-de-25-de-novembro-de-2019
 *
 * @param {String} value Título eleitoral
 * @returns {Boolean}
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
const ValidationBRError_1 = __importDefault(require("./data/ValidationBRError"));
const utils_1 = require("./utils");
/**
 * dv()
 * Calcula o dígito verificador
 *
 * @param {String} value
 * @returns {String}
 */
const dv = (value) => {
    const nup = (0, utils_1.clearValue)(value, 15, { rejectEmpty: true, trimAtRight: true });
    const nupReverse = nup.split('').reverse().join('');
    const sum1 = (0, utils_1.sumElementsByMultipliers)(nupReverse, [...Array(15)].map((_, i) => i + 2));
    const dv1 = _specificSumToDV(sum1);
    const sum2 = (0, utils_1.sumElementsByMultipliers)(dv1 + nupReverse, [...Array(16)].map((_, i) => i + 2));
    const dv2 = _specificSumToDV(sum2);
    return `${dv1}${dv2}`;
};
exports.dv = dv;
/**
 * Aplica uma máscara ao número informado
 *
 * @param {String} value Número de Processo
 * @returns {String} Valor com a máscara
 */
const mask = (value) => (0, utils_1.applyMask)(value, '00000.000000/0000-00');
exports.mask = mask;
/**
 * fake()
 * Gera um número válido
 *
 * @param {Boolean} withMask Define se o número deve ser gerado com ou sem máscara
 * @returns {String}
 */
const fake = (withMask = false) => {
    const num = (0, utils_1.fakeNumber)(15, true);
    const nup = `${num}${(0, exports.dv)(String(num))}`;
    if (withMask)
        return (0, exports.mask)(nup);
    return nup;
};
exports.fake = fake;
/**
 * validateOrFail()
 * Valida se um número é válido e
 * retorna uma exceção se não estiver
 *
 * @param {String} value Número a ser validado
 * @returns {Boolean}
 */
const validateOrFail = (value) => {
    const nup = (0, utils_1.clearValue)(value, 17, {
        rejectEmpty: true,
        rejectHigherLength: true,
    });
    if ((0, exports.dv)(nup) !== nup.substring(15, 17)) {
        throw ValidationBRError_1.default.INVALID_DV;
    }
    return true;
};
exports.validateOrFail = validateOrFail;
/**
 * validate()
 * Valida se um número é válido
 *
 * @param {String} value Número a ser validado
 * @returns {Boolean}
 */
const validate = (value) => {
    try {
        return (0, exports.validateOrFail)(value);
    }
    catch (error) {
        return false;
    }
};
exports.validate = validate;
exports.default = exports.validate;
function _specificSumToDV(sum) {
    const rest = 11 - (sum % 11);
    const exceptions = [
        { rest: 11, dv: 1 },
        { rest: 10, dv: 0 },
    ];
    const inExceptions = exceptions.find((item) => item.rest === rest);
    return !inExceptions ? rest : inExceptions.dv;
}
//# sourceMappingURL=nup17.js.map